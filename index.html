<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Rock Hole!</title>
<style>
body{margin:0;overflow:hidden;font-family:sans-serif}
canvas{display:block;width:100vw;height:100vh;outline:none; cursor: grab;}
canvas:active { cursor: grabbing; }
#sc{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.7);color:#fff;padding:8px 15px;border-radius:5px;z-index:10}
#st{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.7);color:#fff;padding:8px 15px;border-radius:5px;z-index:10;display:flex;flex-direction:column;gap:5px}
#ctrls{position:absolute;bottom:10px;left:10px;z-index:10}
#mb,#etb{color:#fff;padding:10px 20px;border:none;border-radius:8px;cursor:pointer;font-size:1em;box-shadow:0 4px 6px rgba(0,0,0,.1);transition:background-color .3s ease,transform .1s ease}
#mb{background-color:#007bff}
#etb{background-color:#28a745;margin-left:10px}
#mn{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:20;transition:opacity .3s ease;opacity:0;visibility:hidden}
#mn.active{opacity:1;visibility:visible}
#mn button{background-color:#4CAF50;color:#fff;padding:15px 30px;border:none;border-radius:10px;cursor:pointer;font-size:1.5em;margin:10px;width:80%;max-width:300px}
#mn #cmb{background-color:#dc3545}
.modal{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.95);display:flex;justify-content:center;align-items:center;z-index:30;opacity:0;visibility:hidden;transition:opacity .3s ease}
.modal.active{opacity:1;visibility:visible}
.mc{background:#222;color:#fff;padding:30px;border-radius:15px;max-width:600px;text-align:left}
.mc h3{text-align:center;margin-top:0;color:#00ffff}
.mc button{display:block;margin:20px auto 0;background-color:#007bff;color:#fff;padding:10px 25px;border:none;border-radius:8px;cursor:pointer}
#aperture{position:absolute;top:0;left:0;width:100%;height:100%;z-index:5;pointer-events:none;transition:background .1s ease}
</style>
</head>
<body>
<div id="sc">Skits Down: 0</div>
<div id="st"><div id="spc">Speed: 0.00</div><div id="hpc">Height: 0.00</div><div id="dsc">Dist: 0.00</div></div>
<div id="ctrls"><button id="mb">Menu</button><button id="etb" style="display:none;">End Throw</button></div>
<div id="mn">
<button id="hpb">How to Play</button>
<button id="trb">Toggle Rocks</button>
<button id="tcb">Toggle Camera</button>
<button id="rgb">Reset Game</button>
<button id="cmb">Close Menu</button>
</div>
<div id="hpm" class="modal"><div class="mc"><h3>How to Play</h3><p><strong>Throw:</strong> Click/touch the ball, drag, and release.<br><strong>Aftertouch:</strong> After throwing, swipe to steer the ball.<br><strong>Camera:</strong> Right-click/two-finger drag to rotate. Scroll/pinch to zoom.<br><strong>Keys:</strong> Space=Reset, Arrows=Nudge/Throw, Q/E=Spin</p><button id="chpb">Got It!</button></div></div>
<div id="scm" class="modal"><div class="mc"><h3>Game Over!</h3><p>Final Score: <span id="fsc">0</span></p><button id="pab">Play Again!</button></div></div>
<div id="aperture"></div>
<canvas id="cv" tabindex="0"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
// --- Basic setup variables ---
let s,c,r,oc,w,bm,bb,sm=[],sb=[],lm,lb,rc=new THREE.Raycaster();
let isDragging=false,dragPts=[],skitsDown=0,isBallThrown=false,isInit=false,isApplyingAftertouch=false,aftertouchStart=new THREE.Vector2();
let ballCamProxy,ballCam,activeCam,camToggleBtn,isBallCamActive=false,isDragCam=false,lastPointerX=0,lastPointerY=0,camYaw=0,camPitch=0,initPinchDist=0;
let isCamMoving=false,camMoveStartT=0,camMoveStartPos=new THREE.Vector3(),camMoveTargetPos=new THREE.Vector3(0,5,0);
const laneTopY = 0.2;
const ballRadius = 0.25;
const BALL_START_POS=new THREE.Vector3(0, laneTopY + ballRadius, 0),SKITTLE_H=1,SKITTLE_R_T=.08,SKITTLE_R_B=.12,TILE_S=10,TILE_COUNT_X=30,TILE_COUNT_Z=30,ROCK_SPAWN_CHANCE=.08;
const RENDER_DIST=(TILE_COUNT_X/2)*TILE_S, MAX_SPEED = 150;
let groundTiles=[],matBall=new CANNON.Material(),matSkittle=new CANNON.Material(),matLane=new CANNON.Material(),matRock=new CANNON.Material(),matGround=new CANNON.Material(),matRing=new CANNON.Material();
const byId=id=>document.getElementById(id);
let isStopped=false,stopTime=0,scoreSaved=false,throwDist=0,throwStartPos=new CANNON.Vec3(),lastStatUpd=0,frameCnt=0;
const TRAIL_PTS=150,SPARKLE_CNT=6;
let trailPos=[],trail,sparkles,sparkleGeo,sparkleMat,isTrailActive=false;
let isBallConsumed=false;
const BLACK_HOLE_START_POS = new THREE.Vector3(0, 0.01, 25);

// --- Black Hole Object ---
const blackHole={core:null,influence:null,pos:new THREE.Vector3().copy(BLACK_HOLE_START_POS),despawnCount:0,baseRadius:1.5,visible:false,init(scn){this.core=new THREE.Mesh(new THREE.CircleGeometry(1,16),new THREE.MeshBasicMaterial({color:0x000000}));this.core.rotation.x=-Math.PI/2;this.core.position.copy(this.pos);scn.add(this.core);this.influence=new THREE.Mesh(new THREE.SphereGeometry(1,16,8),new THREE.MeshBasicMaterial({color:0x480048,transparent:true,opacity:.2,wireframe:true}));this.influence.position.copy(this.pos);scn.add(this.influence);this.setVisible(false);},grow(amt=1){this.despawnCount+=amt;},setVisible(state){this.visible=state;this.core.visible=state;this.influence.visible=state;},reset(){this.pos.copy(BLACK_HOLE_START_POS);this.core.position.copy(this.pos);this.influence.position.copy(this.pos);this.despawnCount=0;this.setVisible(false);},update(ballPos,ballBody,isConsumed){if(!this.visible)return;const targetRadius=this.baseRadius+Math.log1p(this.despawnCount*5.0);this.core.scale.lerp(new THREE.Vector3(targetRadius,targetRadius,targetRadius),.05);const influenceRadius=targetRadius*4;this.influence.scale.lerp(new THREE.Vector3(influenceRadius,influenceRadius,influenceRadius),.05);rockPool.p.forEach(rock=>{if(rock.active&&rock.m.position.distanceTo(this.pos)<this.core.scale.x){rockPool.consume(rock);}});if(isConsumed)return;this.pos.lerp(ballPos,.005);this.core.position.y=.01;this.influence.position.y=influenceRadius/2;this.core.position.x=this.pos.x;this.core.position.z=this.pos.z;this.influence.position.x=this.pos.x;this.influence.position.z=this.pos.z;const distToCore=ballBody.position.distanceTo(this.pos);if(distToCore<influenceRadius){const pullVec=new CANNON.Vec3(this.pos.x-ballBody.position.x,0,this.pos.z-ballBody.position.z);const pullStrength=Math.max(0,(influenceRadius-distToCore)*.05);pullVec.normalize();pullVec.scale(pullStrength,pullVec);ballBody.applyForce(pullVec,ballBody.position);}}};

// --- Ring Pool Object ---
const ringPool={p:[],init(scn,wrld){this.s=scn;this.w=wrld;this.p=[];},create(pos,rot){const ringGeo=new THREE.TorusGeometry(2,.2,8,24);const ringMat=new THREE.MeshStandardMaterial({color:0xffd700,emissive:0xaaaa00});const m=new THREE.Mesh(ringGeo,ringMat);m.position.copy(pos);m.rotation.copy(rot);this.s.add(m);const b=new CANNON.Body({mass:0,type:CANNON.Body.KINEMATIC,material:matRing,collisionResponse:false});b.addShape(new CANNON.Sphere(2.2));b.position.copy(pos);this.w.addBody(b);const o={m,b,active:true};this.p.push(o);b.userData={ring:o};return o;},release(o,isMiss=false){if(o.active){o.active=false;o.m.visible=false;o.b.collisionResponse=false;if(!isMiss){blackHole.grow(5);const boost=1.15;bb.velocity.scale(boost,bb.velocity);}
this.spawnRing();}},reset(){this.dispose();},dispose(){this.p.forEach(o=>{this.s.remove(o.m);o.m.geometry.dispose();o.m.material.dispose();this.w.removeBody(o.b);});this.p=[];},spawnRing(isInitial=false,index=0){const difficulty=Math.min(10,blackHole.despawnCount/10);let forwardDist,horizontalOffset,verticalOffset;let basePos,rot;const activeRings=this.p.filter(r=>r.active).length;if(activeRings>3)return;if(isInitial||blackHole.despawnCount<5){const ballFwd=new THREE.Vector3(bb.velocity.x,0,bb.velocity.z).normalize();if(ballFwd.lengthSq()===0)ballFwd.set(0,0,-1);forwardDist=isInitial?80+index*60:60;basePos=bm.position.clone().add(ballFwd.multiplyScalar(forwardDist));basePos.y=Math.max(10,bm.position.y+5);rot=new THREE.Euler(0,0,0);}else{forwardDist=120+difficulty*5;horizontalOffset=15+difficulty*2;verticalOffset=10+difficulty;const ballFwd=new THREE.Vector3(bb.velocity.x,0,bb.velocity.z).normalize();if(ballFwd.lengthSq()===0)ballFwd.set(0,0,-1);basePos=bm.position.clone().add(ballFwd.clone().multiplyScalar(forwardDist));const sideVec=new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0),ballFwd).normalize();basePos.add(sideVec.multiplyScalar((Math.random()-.5)*2*horizontalOffset));basePos.y=Math.max(5,bm.position.y+(Math.random()-.5)*verticalOffset);const lookAtPos=bm.position.clone();const tempMesh=new THREE.Object3D();tempMesh.position.copy(basePos);tempMesh.lookAt(lookAtPos);rot=tempMesh.rotation;}
this.create(basePos,rot);}};

// --- Game State Functions ---
function saveScore(){if(scoreSaved)return;scoreSaved=true;byId('fsc').innerText=skitsDown;byId('scm').classList.add('active');}
function toggleMenu(){byId('mn').classList.toggle('active');}
function showModal(m){byId(m).classList.add('active');byId('mn').classList.remove('active');}
function hideModal(m){byId(m).classList.remove('active');}

// --- Rock Pool Object ---
const rockPool={p:[],init(scn,wrld){this.s=scn;this.w=wrld;this.p=[];},create(isInit=false){let m,b,h,w,d,rad;const mat=new THREE.MeshStandardMaterial({color:0x696969,transparent:true,opacity:1});const sc=Math.random()*4.5+.5;h=sc*(Math.random()*1.5+1);if(Math.random()<.5){w=sc*2;d=sc*2;m=new THREE.Mesh(new THREE.BoxGeometry(w,h*.5,d),mat);b=new CANNON.Body({mass:0,material:matRock});b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h*.25,d/2)));}else{rad=sc*1.2;m=new THREE.Mesh(new THREE.ConeGeometry(rad,h,4),mat);b=new CANNON.Body({mass:0,material:matRock});b.addShape(new CANNON.Cylinder(.001,rad,h,4));}
m.castShadow=true;m.receiveShadow=true;this.s.add(m);this.w.addBody(b);m.rotation.set((Math.random()*Math.PI/6)*(Math.random()>.5?1:-1),Math.random()*Math.PI*2,0);const o={m,b,ap:isInit?1:0,isAi:!isInit,isAo:false,s:new THREE.Vector3(1,1,1),o:1,active:isInit,isConsuming:false};if(isInit){m.scale.copy(o.s);m.material.opacity=o.o;m.visible=true;b.collisionResponse=true;b.wakeUp();}else{m.scale.set(.05,.05,.05);m.material.opacity=.05;m.visible=true;b.collisionResponse=false;b.sleep();}
this.p.push(o);return o;},update(){this.p.forEach(o=>{if(o.isConsuming){o.m.scale.lerp(new THREE.Vector3(0,0,0),.1);if(o.m.scale.x<.05){o.isConsuming=false;o.active=false;o.m.visible=false;o.b.collisionResponse=false;}}else if(o.isAi||o.isAo){let animSpd=o.isAi?.015:-.02;o.ap+=animSpd;o.ap=Math.max(0,Math.min(1,o.ap));const sc=THREE.MathUtils.lerp(.05,o.s.x,o.ap);o.m.scale.set(sc,sc,sc);o.m.material.opacity=THREE.MathUtils.lerp(.05,1,o.ap);o.m.visible=o.ap>0;if(o.isAi&&o.ap>=1){o.isAi=false;o.active=true;o.b.collisionResponse=true;o.b.wakeUp();}else if(o.isAo&&o.ap<=0){o.isAo=false;o.active=false;o.m.visible=false;o.b.collisionResponse=false;blackHole.grow(2);}}
if(o.b&&o.active&&!o.isConsuming){o.b.position.copy(o.m.position);o.b.quaternion.copy(o.m.quaternion);}});},get(){const o=this.p.find(obj=>!obj.active&&!obj.isAi&&!obj.isAo);return o?o:this.create(false);},consume(o){if(o.active&&!o.isConsuming){o.isConsuming=true;o.b.type=CANNON.Body.STATIC;blackHole.grow(5);}},toggleVisible(){this.p.forEach(o=>{o.m.visible=!o.m.visible;if(o.b)o.b.collisionResponse=o.m.visible;});},dispose(){this.p.forEach(o=>{this.s.remove(o.m);o.m.geometry.dispose();o.m.material.dispose();if(o.b)this.w.removeBody(o.b);});this.p=[];}};

function isSafeRockPos(x,z){const bounds={xMin:-6.5,xMax:6.5,zMin:-20,zMax:10};return x<bounds.xMin||x>bounds.xMax||z<bounds.zMin||z>bounds.zMax;}

function resetGame(){bb.position.copy(BALL_START_POS);bm.position.copy(BALL_START_POS);bb.velocity.set(0,0,0);bb.angularVelocity.set(0,0,0);bb.type=CANNON.Body.DYNAMIC;bb.allowSleep=false;bb.collisionFilterGroup=1;bb.collisionFilterMask=-1;bm.scale.set(1,1,1);bm.visible=true;isDragging=false;oc.enabled=true;const p=[{x:0,z:-8},{x:-.25,z:-8.5},{x:.25,z:-8.5},{x:-.5,z:-9},{x:0,z:-9},{x:.5,z:-9},{x:-.75,z:-9.5},{x:-.25,z:-9.5},{x:.25,z:-9.5},{x:.75,z:-9.5}];sb.forEach((b,i)=>{b.position.set(p[i].x,laneTopY+SKITTLE_H/2,p[i].z);b.quaternion.set(0,0,0,1);b.velocity.set(0,0,0);b.angularVelocity.set(0,0,0);b.sleep();});sm.forEach((m,i)=>{m.position.set(p[i].x,laneTopY+SKITTLE_H/2,p[i].z);m.rotation.set(0,0,0);});skitsDown=0;byId('sc').innerText=`Skits Down: ${skitsDown}`;isBallThrown=false;ballCamProxy.position.copy(BALL_START_POS);camYaw=0;camPitch=0;ballCamProxy.rotation.set(0,0,0);ballCam.position.set(0,5,15);ballCam.lookAt(ballCamProxy.position);isBallCamActive=false;activeCam=c;oc.enabled=true;camToggleBtn.innerText="Toggle Camera (Main)";isCamMoving=false;c.position.set(0,10,25);oc.target.set(0,1,0);oc.update();rockPool.dispose();createGround();createRocks();ringPool.dispose();hideModal('scm');isStopped=false;stopTime=0;scoreSaved=false;throwDist=0;throwStartPos.copy(BALL_START_POS);byId('dsc').innerText=`Dist: 0.00`;byId('etb').style.display='none';trailPos=[];trail.geometry.setDrawRange(0,0);trail.visible=false;isTrailActive=false;sparkles.visible=false;byId('aperture').style.background='none';isBallConsumed=false;blackHole.reset();}

function checkSkittlesDown(){let fallen=0;const up=new CANNON.Vec3(0,1,0);const threshold=Math.cos(Math.PI/4);sb.forEach(b=>{const yVec=b.quaternion.vmult(up);if(yVec.dot(up)<threshold)fallen++;});if(fallen!==skitsDown){blackHole.grow(fallen-skitsDown);skitsDown=fallen;byId('sc').innerText=`Skits Down: ${skitsDown}`;}}

// --- Event Handlers ---
function onResize(){c.aspect=ballCam.aspect=window.innerWidth/window.innerHeight;c.updateProjectionMatrix();ballCam.updateProjectionMatrix();r.setSize(window.innerWidth,window.innerHeight);}

function onPointerDown(e){
    if(isBallConsumed) return;
    
    const isTouch = e.type === 'touchstart';
    const pX = isTouch ? e.touches[0].clientX : e.clientX;
    const pY = isTouch ? e.touches[0].clientY : e.clientY;
    const pointer = new THREE.Vector2((pX / window.innerWidth) * 2 - 1, -(pY / window.innerHeight) * 2 + 1);

    if (isBallThrown) {
        isApplyingAftertouch = true;
        aftertouchStart.set(pX, pY);
        return;
    }

    // --- NEW: Check if the click is on the ball ---
    rc.setFromCamera(pointer, c);
    const intersects = rc.intersectObject(bm); // bm is the ball mesh

    if (intersects.length > 0 || isTouch) { // For touch, we allow grabbing without a direct hit
        // Only proceed if it's a left-click or a touch event
        if ((!isTouch && e.button === 0) || isTouch) {
            isDragging = true;
            oc.enabled = false; // Disable camera controls during drag
            dragPts = [];
            dragPts.push({ p: pointer.clone(), t: performance.now() });

            // Set physics body to kinematic to control it directly
            bb.type = CANNON.Body.KINEMATIC;
            bb.velocity.set(0, 0, 0);
            bb.angularVelocity.set(0, 0, 0);

            // Move ball to cursor position on the lane plane
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -BALL_START_POS.y);
            const iPt = new THREE.Vector3();
            rc.ray.intersectPlane(plane, iPt);
            if (iPt) {
                iPt.x = Math.max(-1.4, Math.min(1.4, iPt.x));
                iPt.z = Math.max(iPt.z, 5); // Prevent dragging too far back
                bm.position.copy(iPt);
                bb.position.copy(iPt);
            }
        }
    }
}

function onPointerMove(e){
    if (!isDragging) return;
    if(isBallConsumed) return;

    const isTouch=e.type==='touchmove';
    const pX=isTouch?e.touches[0].clientX:e.clientX;
    const pY=isTouch?e.touches[0].clientY:e.clientY;
    const pointer = new THREE.Vector2((pX/window.innerWidth)*2-1,-(pY/window.innerHeight)*2+1);
    
    dragPts.push({p:pointer.clone(),t:performance.now()});
    if(dragPts.length>20)dragPts.shift();

    rc.setFromCamera(pointer,c);
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -BALL_START_POS.y);
    const iPt=new THREE.Vector3();
    rc.ray.intersectPlane(plane,iPt);
    if(iPt){
        // Keep the ball within the lane's width and a certain starting area
        iPt.x = Math.max(-1.4, Math.min(1.4, iPt.x));
        iPt.z = Math.max(iPt.z, 5); // Prevent dragging too far back
        bm.position.copy(iPt);
        bb.position.copy(iPt);
    }
    e.preventDefault();
}

function onPointerUp(e){
    if (!isDragging) return;
    
    isDragging = false;
    oc.enabled = true; // Re-enable camera controls

    const isTouch=e.type.includes('touch');
    
    bb.type=CANNON.Body.DYNAMIC;
    if(dragPts.length>1){
        const end=dragPts[dragPts.length-1];
        const start=dragPts[Math.max(0,dragPts.length-5)];
        const dV=new THREE.Vector2().subVectors(end.p,start.p);
        
        if(dV.length()>.03){
            const dDur=Math.max(1,end.t-start.t)/1e3;
            const velMag=dV.length()/dDur;
            const hForce=120,fForce=isTouch?500:750,vForce=300;
            const impulse=new CANNON.Vec3(dV.x*hForce*velMag,Math.abs(dV.y)*vForce*velMag,-dV.y*fForce*velMag);
            bb.applyImpulse(impulse,bb.position);
            throwStartPos.copy(bb.position);
            isBallThrown=true;
            blackHole.setVisible(true);
            for(let i=0;i<3;i++){ringPool.spawnRing(true,i);}
            if(isTouch){
                toggleCamera();
            }else{
                isCamMoving=true;
                camMoveStartT=performance.now();
                camMoveStartPos.copy(c.position);
            }
        }
    }
    dragPts=[];
    e.preventDefault();
}

function onKeyDown(e){const nudgeF=.05,throwF=150,spinF=2;if(isBallConsumed)return;switch(e.code){case'Space':resetGame();break;case'ArrowUp':bb.type=CANNON.Body.DYNAMIC;bb.applyImpulse(new CANNON.Vec3(0,0,-throwF),bb.position);throwStartPos.copy(bb.position);isBallThrown=true;blackHole.setVisible(true);break;case'ArrowLeft':bb.applyImpulse(new CANNON.Vec3(-nudgeF,0,0),bb.position);break;case'ArrowRight':bb.applyImpulse(new CANNON.Vec3(nudgeF,0,0),bb.position);break;case'KeyQ':bb.angularVelocity.y-=spinF;break;case'KeyE':bb.angularVelocity.y+=spinF;break;}}

// --- Camera and World Setup ---
function toggleCamera(){isBallCamActive=!isBallCamActive;activeCam=isBallCamActive?ballCam:c;oc.enabled=!isBallCamActive;camToggleBtn.innerText=`Toggle Camera (${isBallCamActive?"Ball":"Main"})`;if(isBallCamActive){ballCamProxy.position.copy(bm.position);camYaw=0;camPitch=0;ballCamProxy.rotation.set(0,0,0);ballCam.position.set(0,5,15);ballCam.lookAt(ballCamProxy.position);}}
function createGround(){groundTiles.forEach(t=>{s.remove(t.m);w.removeBody(t.b);t.m.geometry.dispose();t.m.material.dispose();});groundTiles=[];const m1=new THREE.MeshStandardMaterial({color:0x228b22}),m2=new THREE.MeshStandardMaterial({color:0x3cb371});const g=new THREE.PlaneGeometry(TILE_S,TILE_S),sx=BALL_START_POS.x-(TILE_COUNT_X/2)*TILE_S,sz=BALL_START_POS.z-(TILE_COUNT_Z/2)*TILE_S;for(let i=0;i<TILE_COUNT_X;i++)for(let j=0;j<TILE_COUNT_Z;j++){const m=new THREE.Mesh(g,(i+j)%2===0?m1:m2);m.rotation.x=-Math.PI/2;m.receiveShadow=true;const b=new CANNON.Body({mass:0,material:matGround});b.addShape(new CANNON.Plane());b.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);const x=sx+i*TILE_S+TILE_S/2,z=sz+j*TILE_S+TILE_S/2;m.position.set(x,0,z);b.position.copy(m.position);s.add(m);w.addBody(b);groundTiles.push({m,b});}}
function updateGround(){const bx=bb.position.x,bz=bb.position.z,hx=TILE_COUNT_X/2,hz=TILE_COUNT_Z/2,wx=hx*TILE_S,wz=hz*TILE_S;groundTiles.forEach(t=>{const oldPos=t.m.position.clone();let moved=false;if(t.m.position.z<bz-wz){t.m.position.z+=TILE_COUNT_Z*TILE_S;moved=true;}else if(t.m.position.z>bz+wz){t.m.position.z-=TILE_COUNT_Z*TILE_S;moved=true;}
if(t.m.position.x<bx-wx){t.m.position.x+=TILE_COUNT_X*TILE_S;moved=true;}else if(t.m.position.x>bx+wx){t.m.position.x-=TILE_COUNT_X*TILE_S;moved=true;}
if(moved){const halfTS=TILE_S/2;rockPool.p.forEach(rock=>{if(rock.active){const rp=rock.m.position;if(rp.x>oldPos.x-halfTS&&rp.x<oldPos.x+halfTS&&rp.z>oldPos.z-halfTS&&rp.z<oldPos.z+halfTS){if(!rock.isAo&&!rock.isConsuming){rock.isAo=true;rock.isAi=false;}}}});t.b.position.copy(t.m.position);if(Math.random()<ROCK_SPAWN_CHANCE){const rk=rockPool.get();if(rk){const rkX=t.m.position.x+(Math.random()-.5)*TILE_S,rkZ=t.m.position.z+(Math.random()-.5)*TILE_S;if(isSafeRockPos(rkX,rkZ)){const h=(rk.m.geometry.parameters.height||rk.m.geometry.parameters.radius*2||2)/2;rk.m.position.set(rkX,h,rkZ);rk.b.position.copy(rk.m.position);rk.m.rotation.set((Math.random()*Math.PI/6)*(Math.random()>.5?1:-1),Math.random()*Math.PI*2,0);rk.b.quaternion.copy(rk.m.quaternion);rk.b.velocity.set(0,0,0);rk.b.angularVelocity.set(0,0,0);rk.isAi=true;rk.ap=0;}}}}});}
function cullObjects(){const bPos=bb.position;const RENDER_DIST_SQ=RENDER_DIST*RENDER_DIST;groundTiles.forEach(t=>{const isVis=t.m.position.distanceToSquared(new THREE.Vector3(bPos.x,bPos.y,bPos.z))<RENDER_DIST_SQ;if(t.m.visible!==isVis){t.m.visible=isVis;t.b.collisionResponse=isVis;if(!isVis){const hTS=TILE_S/2;rockPool.p.forEach(rock=>{if(rock.active){const rp=rock.m.position;if(rp.x>t.m.position.x-hTS&&rp.x<t.m.position.x+hTS&&rp.z>t.m.position.z-hTS&&rp.z<t.m.position.z+hTS){if(!rock.isAo&&!rock.isConsuming){rock.isAo=true;rock.isAi=false;}}}});}}});}
function createRocks(){rockPool.init(s,w);const center=new THREE.Vector3(0,0,0);groundTiles.forEach(t=>{if(t.m.position.distanceTo(center)<RENDER_DIST){if(Math.random()<ROCK_SPAWN_CHANCE){const rkX=t.m.position.x+(Math.random()-.5)*TILE_S,rkZ=t.m.position.z+(Math.random()-.5)*TILE_S;if(isSafeRockPos(rkX,rkZ)){const rk=rockPool.create(true);const h=(rk.m.geometry.parameters.height||rk.m.geometry.parameters.radius*2||2)/2;rk.m.position.set(rkX,h,rkZ);rk.b.position.copy(rk.m.position);rk.m.rotation.set((Math.random()*Math.PI/6)*(Math.random()>.5?1:-1),Math.random()*Math.PI*2,0);rk.b.quaternion.copy(rk.m.quaternion);}}}});}
function createDiamondTex(){const cv=document.createElement('canvas');cv.width=64;cv.height=64;const ctx=cv.getContext('2d');ctx.beginPath();ctx.moveTo(32,0);ctx.lineTo(64,32);ctx.lineTo(32,64);ctx.lineTo(0,32);ctx.closePath();ctx.fillStyle='#ffe88a';ctx.fill();return new THREE.CanvasTexture(cv);}

// --- Init Function ---
function init(){if(isInit)return;isInit=true;const cv=byId('cv');camToggleBtn=byId('tcb');byId('mb').addEventListener('click',toggleMenu);byId('cmb').addEventListener('click',toggleMenu);byId('hpb').addEventListener('click',()=>showModal('hpm'));byId('chpb').addEventListener('click',()=>hideModal('hpm'));byId('trb').addEventListener('click',()=>rockPool.toggleVisible());byId('rgb').addEventListener('click',()=>{resetGame();toggleMenu();});byId('tcb').addEventListener('click',toggleCamera);byId('pab').addEventListener('click',resetGame);byId('etb').addEventListener('click',()=>{saveScore();byId('etb').style.display='none';});

    // --- MOUSE AND TOUCH EVENT LISTENERS ---
    cv.addEventListener('mousedown',onPointerDown);
    cv.addEventListener('touchstart',onPointerDown,{passive:false});
    window.addEventListener('mousemove',onPointerMove);
    window.addEventListener('mouseup',onPointerUp);
    cv.addEventListener('touchmove',onPointerMove,{passive:false});
    cv.addEventListener('touchend',onPointerUp,{passive:false});
    cv.addEventListener('wheel',e=>{if(isBallCamActive){e.preventDefault();ballCam.position.z+=e.deltaY*.05;ballCam.position.z=Math.max(5,Math.min(25,ballCam.position.z));}},{passive:false});
    cv.addEventListener('contextmenu',e=>e.preventDefault());
    document.addEventListener('keydown',onKeyDown);

    cv.focus();s=new THREE.Scene();s.background=new THREE.Color(0x87ceeb);c=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3);c.position.set(0,10,25);ballCam=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3);ballCamProxy=new THREE.Object3D();ballCamProxy.add(ballCam);s.add(ballCamProxy);activeCam=c;r=new THREE.WebGLRenderer({antialias:true,canvas:cv});r.shadowMap.enabled=true;
    
    // --- OrbitControls Setup ---
    oc=new THREE.OrbitControls(c,r.domElement);
    oc.enableDamping=true;
    oc.dampingFactor=.05;
    oc.target.set(0,1,0);
    oc.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };
    oc.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

    s.add(new THREE.AmbientLight(16777215,.6));const dl=new THREE.DirectionalLight(16777215,.8);dl.position.set(5,10,5);dl.castShadow=true;dl.shadow.mapSize.set(1024,1024);dl.shadow.camera.near=.5;dl.shadow.camera.far=50;dl.shadow.camera.left=dl.shadow.camera.bottom=-20;dl.shadow.camera.right=dl.shadow.camera.top=20;s.add(dl);w=new CANNON.World();w.gravity.set(0,-9.82,0);w.broadphase=new CANNON.SAPBroadphase(w);w.allowSleep=true;
    const laneH=.2;
    lm=new THREE.Mesh(new THREE.BoxGeometry(3,laneH,20),new THREE.MeshStandardMaterial({color:0x8B4513}));
    lm.position.set(0,laneH/2, -5); 
    lm.receiveShadow=true;s.add(lm);
    lb=new CANNON.Body({mass:0,material:matLane});
    lb.addShape(new CANNON.Box(new CANNON.Vec3(1.5,laneH/2,10)));
    lb.position.copy(lm.position);w.addBody(lb);
    
    bm=new THREE.Mesh(new THREE.SphereGeometry(ballRadius,16,16),new THREE.MeshStandardMaterial({color:255}));bm.position.copy(BALL_START_POS);bm.castShadow=true;s.add(bm);bb=new CANNON.Body({mass:5,material:matBall,linearDamping:.1,angularDamping:.1,allowSleep:false});bb.addShape(new CANNON.Sphere(ballRadius));bb.position.copy(bm.position);w.addBody(bb);const createSkittle=(x,z)=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(SKITTLE_R_T,SKITTLE_R_B,SKITTLE_H,8),new THREE.MeshStandardMaterial({color:16777215}));m.position.set(x,laneTopY+SKITTLE_H/2,z);m.castShadow=true;m.receiveShadow=true;s.add(m);sm.push(m);const b=new CANNON.Body({mass:.5,material:matSkittle,angularDamping:.2});b.addShape(new CANNON.Cylinder(SKITTLE_R_T,SKITTLE_R_B,SKITTLE_H,8),new CANNON.Vec3,new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1,0,0),Math.PI/2));b.position.copy(m.position);w.addBody(b);sb.push(b);};const p=[{x:0,z:-8},{x:-.25,z:-8.5},{x:.25,z:-8.5},{x:-.5,z:-9},{x:0,z:-9},{x:.5,z:-9},{x:-.75,z:-9.5},{x:-.25,z:-9.5},{x:.25,z:-9.5},{x:.75,z:-9.5}];p.forEach(pos=>createSkittle(pos.x,pos.z));const trailGeo=new THREE.BufferGeometry(),pos=new Float32Array(TRAIL_PTS*3),cols=new Float32Array(TRAIL_PTS*3);trailGeo.setAttribute('position',new THREE.BufferAttribute(pos,3).setUsage(THREE.DynamicDrawUsage));trailGeo.setAttribute('color',new THREE.BufferAttribute(cols,3).setUsage(THREE.DynamicDrawUsage));const trailMat=new THREE.LineBasicMaterial({vertexColors:true,transparent:true,opacity:1,blending:THREE.AdditiveBlending});trail=new THREE.Line(trailGeo,trailMat);trail.visible=false;trail.frustumCulled=false;s.add(trail);sparkleGeo=new THREE.BufferGeometry();const sparklePos=new Float32Array(SPARKLE_CNT*3);sparkleGeo.setAttribute('position',new THREE.BufferAttribute(sparklePos,3));sparkleMat=new THREE.PointsMaterial({size:.25,map:createDiamondTex(),transparent:true,blending:THREE.AdditiveBlending,sizeAttenuation:true,alphaTest:.5});sparkles=new THREE.Points(sparkleGeo,sparkleMat);sparkles.visible=false;sparkles.frustumCulled=false;s.add(sparkles);blackHole.init(s);ringPool.init(s,w);resetGame();w.addContactMaterial(new CANNON.ContactMaterial(matBall,matLane,{friction:.01,restitution:.6}));w.addContactMaterial(new CANNON.ContactMaterial(matBall,matSkittle,{friction:.01,restitution:.3}));w.addContactMaterial(new CANNON.ContactMaterial(matSkittle,matLane,{friction:.8,restitution:.1}));w.addContactMaterial(new CANNON.ContactMaterial(matBall,matRock,{friction:.8,restitution:.1}));w.addContactMaterial(new CANNON.ContactMaterial(matBall,matGround,{friction:.1,restitution:.5}));window.addEventListener('resize',onResize,false);onResize();}

// --- Main Game Loop ---
function loop(){requestAnimationFrame(loop);if(!isInit)return;const groundThreshold=0.3;if(bb.position.y>groundThreshold){bb.linearDamping=0.03;}else{bb.linearDamping=0.1;}
const now=performance.now();w.step(1/60,undefined,3);if(isBallConsumed){const shrinkSpeed=.02;bm.scale.lerp(new THREE.Vector3(0,0,0),shrinkSpeed);const targetPos=new THREE.Vector3(blackHole.pos.x,-2,blackHole.pos.z);bm.position.lerp(targetPos,shrinkSpeed*1.5);if(bm.scale.x<.01){bm.visible=false;saveScore();}}else{bm.position.copy(bb.position);bm.quaternion.copy(bb.quaternion);}
sm.forEach((m,i)=>{m.position.copy(sb[i].position);m.quaternion.copy(sb[i].quaternion);});if(isCamMoving){let t=Math.min(1,(performance.now()-camMoveStartT)/1e3);c.position.lerpVectors(camMoveStartPos,camMoveTargetPos,t);oc.target.copy(bm.position);oc.update();if(t>=1){isCamMoving=false;toggleCamera();}}else if(isBallCamActive){ballCamProxy.position.copy(bm.position);ballCamProxy.rotation.y=camYaw;const tempCamPos=new THREE.Vector3(0,5,ballCam.position.z).applyAxisAngle(new THREE.Vector3(1,0,0),camPitch);ballCam.position.copy(tempCamPos);ballCam.lookAt(ballCamProxy.position);}else{oc.update();if(c.position.y<.5)c.position.y=.5;}
frameCnt++;if(frameCnt%5===0){updateGround();cullObjects();rockPool.update();}
blackHole.update(bm.position,bb,isBallConsumed);ringPool.p.forEach(ring=>{if(ring.active){const ballPos=bm.position;const ringPos=ring.m.position;const dist=ballPos.distanceTo(ringPos);if(dist<2.2){ringPool.release(ring);}else{const ballToRing=new THREE.Vector3().subVectors(ringPos,ballPos);const ballVel=new THREE.Vector3(bb.velocity.x,bb.velocity.y,bb.velocity.z);if(ballToRing.dot(ballVel)<0&&dist>10){ringPool.release(ring,true);}}
}});r.render(s,activeCam);const speed=bb.velocity.length();if(speed>MAX_SPEED){bb.velocity.normalize();bb.velocity.scale(MAX_SPEED,bb.velocity);}
if(now-lastStatUpd>100){lastStatUpd=now;checkSkittlesDown();byId('spc').innerText=`Speed: ${speed.toFixed(2)}`;byId('hpc').innerText=`Height: ${(bb.position.y - BALL_START_POS.y).toFixed(2)}`;if(isBallThrown){throwDist=bb.position.distanceTo(throwStartPos);}
byId('dsc').innerText=`Dist: ${throwDist.toFixed(2)}`;if(isBallThrown&&speed<.25&&throwDist>15&&!scoreSaved&&!isBallConsumed){byId('etb').style.display='block';}else{byId('etb').style.display='none';}}
if(isBallThrown&&throwDist>60&&!isBallCamActive){toggleCamera();}
if(!isBallConsumed&&bb.position.distanceTo(blackHole.pos)<blackHole.core.scale.x){isBallConsumed=true;bb.type=CANNON.Body.STATIC;}
byId('aperture').style.background='none';if(isBallThrown&&speed>1){isTrailActive=true;trailPos.unshift(bm.position.clone());const trailLen=Math.floor(Math.min(1,(speed-1)/100)*(TRAIL_PTS-20)+20);if(trailPos.length>trailLen){trailPos.pop();}}
if(isTrailActive){trail.visible=true;const pos=trail.geometry.attributes.position.array;const cols=trail.geometry.attributes.color.array;let opacF=1;if(speed<.5){opacF=Math.max(0,speed/.5);}else if(speed<1){opacF=Math.min(1,speed/1);}
for(let i=0;i<trailPos.length;i++){const p=trailPos[i];pos[i*3]=p.x;pos[i*3+1]=p.y;pos[i*3+2]=p.z;const col=new THREE.Color(255);const intensity=(trailPos.length-i)/trailPos.length;col.lerp(new THREE.Color(65535),intensity);cols[i*3]=col.r;cols[i*3+1]=col.g;cols[i*3+2]=col.b;}
trail.material.opacity=.5+.5*opacF;trail.geometry.setDrawRange(0,trailPos.length);trail.geometry.attributes.position.needsUpdate=true;trail.geometry.attributes.color.needsUpdate=true;if(speed<.2&&trail.material.opacity<.1){isTrailActive=false;trailPos=[];trail.visible=false;}}else{trail.visible=false;trailPos=[];}
if(isBallThrown&&speed>30){sparkles.visible=true;const speedF=Math.min(1,(speed-30)/125);sparkleMat.size=.1+speedF*.1;sparkleMat.opacity=.5+speedF*.4;const numParticles=Math.floor(3+speedF*(SPARKLE_CNT-3));const pos=sparkleGeo.attributes.position.array;const dir=new THREE.Vector3(bb.velocity.x,bb.velocity.y,bb.velocity.z).normalize();const center=new THREE.Vector3().copy(bm.position).add(dir.multiplyScalar(2.5));const spread=1.5*speedF;for(let i=0;i<numParticles;i++){const idx=i*3;pos[idx]=center.x+(Math.random()-.5)*spread;pos[idx+1]=center.y+(Math.random()-.5)*spread;pos[idx+2]=center.z+(Math.random()-.5)*spread;}
sparkleGeo.setDrawRange(0,numParticles);sparkleGeo.attributes.position.needsUpdate=true;}else{sparkles.visible=false;}
if(isBallCamActive&&speed>30){const speedF=(speed-30)/100;const startStop=Math.max(0,50-speedF*45);const opacity=Math.min(1,.6+speedF*.4);byId('aperture').style.background=`radial-gradient(circle at center,transparent ${startStop}%,rgba(0,0,0,${opacity}) 100%)`;}
if(isBallThrown&&speed<.01&&bb.angularVelocity.length()<.01&&!isBallConsumed){if(!isStopped){isStopped=true;stopTime=performance.now();}else if(performance.now()-stopTime>1000&&!scoreSaved){saveScore();}}else{isStopped=false;stopTime=0;}}
document.addEventListener('DOMContentLoaded',()=>{init();loop();});
</script>
</body>
</html>
